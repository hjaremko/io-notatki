\documentclass[a4paper]{article}

\usepackage{fullpage} % Package to use full page
\usepackage{parskip} % Package to tweak paragraph skipping
\usepackage{tikz} % Package for drawing
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{enumitem}
\usepackage{booktabs}
\usepackage{lmodern}
\usepackage[MeX]{polski}
\usepackage[T1]{fontenc}
\usepackage{float}

\title{Notatki z kursu Inżynieria Oprogramowania}
\author{Małgorzata Dymek}
\date{2018/19, semestr letni}

\begin{document}
    \maketitle


    \section{Podstawowe pojęcia}


    \begin{table}[H]
        \begin{center}
            \begin{tabular}{  p{8cm} p{8cm}  }
                \textbf{Inżynieria oprogramowania}
                &
                Zastosowanie \textbf{inżynierskiego} (systematycznego, zdyscyplinowanego, ilościowego) \textbf{podejścia}
                do oprogramowania (rozwoju, eksploatacji, utrzymania).
                \\
                \cmidrule(r){1-1}\cmidrule(l){2-2}
                Produkcja oprogramowania
                &
                \begin{itemize}
                    \item analiza,
                    \item wymagania,
                    \item projektowanie,
                    \item wdrożenie, ewolucja systemu
                \end{itemize}
                \\
                \cmidrule(r){1-1}\cmidrule(l){2-2}
                Proces tworzenia oprogramowania
                &
                \textbf{Zbiór czynności} i związanych z nimi wyników, \textbf{prowadzących do powstania
                systemu} informatycznego - tworzenie oprogramowania od zera, rozszerzanie i modyfikowanie istniejących systemów.
                \\
                \cmidrule(r){1-1}\cmidrule(l){2-2}
                Uczestnicy i \textbf{role} & \\

                \textbf{Systemy} i \textbf{modele} & \\
                \cmidrule(r){1-1}\cmidrule(l){2-2}
                \textbf{Produkt} - wewnętrzny lub docelowy
                &
                \begin{itemize}
                    \item specyfikacja
                    \item podręcznik użytkowania
                    \item scenariusze przypadków użycia
                    \item raport o statusie projektu
                    \item podręcznik testera
                \end{itemize}
                \\
                \cmidrule(r){1-1}\cmidrule(l){2-2}
                \textbf{Aktywności}, zadania i \textbf{zasoby}.
                &
                \begin{itemize}
                    \item zbieranie, analizowanie wymagań
                    \item realizacja przypadku użycia
                    \item projektowanie systemu, obiektów
                    \item implementacja, testowanie
                    \item komunikacja,
                    \item zarządzanie konfiguracją, projektem
                    \item cykl życiowy oprogramowania
                \end{itemize}
                \\
                \cmidrule(r){1-1}\cmidrule(l){2-2}
                \textbf{Notacje}, \textbf{metody} i \textbf{metodologie}
                &
                UML
                \\

                \textbf{Wymagania} - funkcjonalne i niefunkcjonalne & \\

            \end{tabular}
        \end{center}
    \end{table}



    \section {UML}
    \textbf{UML - Unified Modelling Language}
    \begin{itemize}
        \item rodzina \textbf{notacji} graficznych; unifikacja wielu obiektowych języków modelowania graficznego.
        \item służy do opisywania i projektowania stystemów informatycznych.
        \item nadzorowany przez organizacje OMG
        \item dwie podstawowe części:
        \begin{itemize}
            \item \textbf{Notacja} - składnia oraz elementy graficzne.
            \item \textbf{Metamodel} - semantyka oraz definicje pojęć języka i ich powiązań.
        \end{itemize}
    \end{itemize}
    \hfill \\
    \textbf{Sposoby użycia UML}:

    \begin{table}[H]
        \begin{center}
            \begin{tabular}{  p{5cm} p{5cm}  p{5cm} }
                \toprule
                \textbf{Szkic} & \textbf{Projekt} & \textbf{Język programowania}\\

                \cmidrule(r){1-1}\cmidrule(rl){2-2}\cmidrule(l){3-3}

                \begin{itemize}
                    \item użyteczny podczas tworzenia i odtwarzania,
                    \item charakter selektywny, nieformalny, dynamiczny.
                \end{itemize}
                &
                \begin{itemize}
                    \item użyteczny podczas tworzenia i odtwarzania,
                    \item powinien być kompletny i zawierać wszystkie istotne decyzje,
                    \item może dotyczyć tylko części systemu,
                    \item wymaga bardziej skomplikowanych narzędzi niż szkic.
                \end{itemize}
                &
                \begin{itemize}
                    \item diagramy tak szczegółowe, ze można generować kod automatycznie,
                    \item wymaga bardzo skomplikowanych narzędzi.
                \end{itemize}
                \\


                \bottomrule
            \end{tabular}
        \end{center}
    \end{table}


    \textbf{Aktor} - użytkownik systemu; ogólnie wszystkie role, które wchodzą w interakcje z systemem, komponenty \underline{odpowiedzialne
    za incijalizację} use casów.

    \textbf{Scenariusz przypadku użycia} - wyspecyfikowana \underline{sekwencja zdarzeń} między użytkownikiem a systemem.
    \begin{itemize}
        \item Zdefiniowane w pierwszej kolejności.
        \item Wyróżnia się jeden \textbf{główny scenariusz sukcesu}.
        \item Może zawierać warunki wstępne, gwarancje lub wyzwalacze.
        \item W agile development używa się \underline{skróconej wersji scenariusza} odpowiadającej
        na pytania: kto, co, dlaczego.
    \end{itemize}

    \textbf{Przypadek użycia} - \underline{zbiór powiązanych ze sobą scenariuszy} opisujących użycie systemu przez aktorów.
    Opisujemy je tekstowo, poprzez user stories lub diagramy.
    \begin{itemize}
        \item reprezentuje \textbf{funkcjonalne wymaganie} systemu;
        \item pewna historia; opisuje akcje systemu z punktu widzenia użytkownika;
        \item specyfikuje jeden aspekt zachowania bez wchodzenia w strukturę systemu;
        \item jest zorientowany na osiągnięcie celu użytkownika;
    \end{itemize}
    Diagramy przypadków użycia są używane do modelowania kontekstu i wymagań systemu.

    \begin{figure}[H]
        \includegraphics[width=\linewidth]{usecases.png}
    \end{figure}


    \subsection{Diagramy UML}
    \begin{table}[H]
        \begin{center}
            \begin{tabular}{  p{8cm} p{8cm} }
                \toprule
                \textbf{Strukturalne} & \textbf{Behawioralne}\\

                \cmidrule(r){1-1}\cmidrule(r){2-2}

                \begin{itemize}
                    \item diagram klas
                    \item diagram komponentów
                    \item diagram obiektów
                    \item diagram pakietów
                    \item diagram wdrożenia
                    \item diagram struktur złożonych
                \end{itemize}
                &
                \begin{itemize}
                    \item diagram czynności
                    \item diagram stanów
                    \item diagram przypadków użycia
                    \item diagram komunikacji
                    \item diagram sekwencji
                    \item diagram przeglądu
                    \item diagram przebiegów czasowych
                \end{itemize}
                \\

                \bottomrule
            \end{tabular}
        \end{center}
    \end{table}


    \subsubsection{Diagram klas}
    \begin{itemize}
        \item jeden z najczęściej używanych, zwłaszcza do \textbf{generowania kodu}.
        \item ilustracja w modelach obiektowych struktury klas i zależności między nimi,
        \item podział odpowiedzialności pomiędzy klasy i rodzaj wymienianych komunikatów,
    \end{itemize}

    \textbf{Klasy} służą do opanowania słownictwa tworzonego systemu. Używane do przedstawienia bytów programowych, sprzętowych,
    koncepcyjnych.


    \begin{table}[H]
        \begin{center}
            \begin{tabular}{ c p{8cm} }
                \raisebox{-\totalheight}{\includegraphics[width=0.5\textwidth, height=60mm]{diagram_klasy.png}}
                &
                \begin{itemize}
                    \item \textbf{Parametr} - przyjmowany przez metodę.
                    \item \textbf{Atrybut} - nazwana właściwość klasy. Może mieć podaną klasę i wartość początkową.
                    \begin{itemize}
                        \item $+$  public
                        \item \# protected
                        \item $-$ private
                    \end{itemize}
                    \item \textbf{Operacja} (metoda) - implementacja pewnej usługi, której wykonania można zarządać
                    od każdego obiektu klasy. Dokładne określenie przez podanie sygnatury (typy i domyślne wartości parametrów).
                    \item \textbf{Odpowiedzialność} - wyrażenie zobowiązań klasy (lista).

                    \item \textbf{Instancja} - każdy egzemplarz przechowuje oddzielną wartość
                    \item \textbf{Classifier} - jest tylko jedna wartość wspólna dla wszystkich egzemplarzy
                    \item \textbf{Ilość wystąpień} - liczba w prawym górnym rogu ($1 = singleton$)
                \end{itemize}
                \\
            \end{tabular}
        \end{center}
    \end{table}


    \begin{figure}[H]
        \includegraphics[width=\linewidth]{uml_zwiazki.png}
    \end{figure}

    Dodatkowo:
    \begin{itemize}
        \item \textbf{Implementacja} - linia przerywana
        zakończona pustą strzałką.
        \item \textbf{Rozszerzenia}
        \begin{itemize}
            \item \textbf{stereotypy} - służą do stworzenia nowego rodzaju obiektu ma podstawie innego obiektu
            będącego już w standardzie UML.
            \item \textbf{ograniczenia} - dotyczą zarówno klas jak i związków między nimi.
        \end{itemize}
        \item \textbf{Szablony} - klasy parametryzowane. Parametry szablony w prostokącie z przerywanych linii
        obok diagramu klasy.
    \end{itemize}


    \subsection{Procesy wytwarzania oprogramowania}

    \textbf{Cztery fundamentalne działania }wspólne dla wszystkich procesów:
    \begin{itemize}
        \item \textbf{Specyfikowanie} oprogramowania
        \begin{itemize}
            \item zebranie wymagań,
            \item definiowanie funkcjonalności i ograniczeń dotyczących
            tworzonego software’u.
        \end{itemize}
        \item \textbf{Tworzenie} oprogramowania
        \item \textbf{Walidacja} oprogramowania
        \item \textbf{Ewolucja} oprogramowania
    \end{itemize}

    \hfill \\
    \textbf{Cykl życia systemu} - cały okres istnienia systemu:
    \begin{itemize}
        \item studium zastosowalności,
        \item analiza i specyfikacja,
        \item projektowanie i tworzenie,
        \item wdrażanie,
        \item pielęgnacja,
        \item aspekty usprawnienia.
    \end{itemize}

    \subsection{Modele procesu wytwarzania oprogramowania}
    \textbf{Model cyklu życia} systemu informatycznego ma na celu \underline{przedstawienie procesu} wytwarzania
    oprogramowania, który prowadzi do stworzenia działającego systemu.


    \subsubsection{Model kaskadowy}
    \begin{itemize}
        \item \textbf{wyizolowane etapy}, każdy musi być zakończony przed rozpoczęciem kolejnego
        \begin{itemize}
            \item \underline{Planowanie}: cele biznesowe, podstawowe wymagania, założenia, standardy, parametry,
            \item \underline{Analiza}: zdefiniowanie przeznaczenia systemu $\rightarrow$ kompletny, spójny i jednoznaczny model systemu,
            \item \underline{Projekt}: dekompozycja na podsystemy, wybór strategii budowania, projektowanie obiektów, wybór komponentów, opis interfejsów,
            \item \underline{Implementacja}: tworzenie kodu źródłowego, mapowanie modeli na kod,
            \item \underline{Testowanie}: znajdowanie różnic między rzeczywistym elementem a jego modelem,
            \item \underline{Pielęgnacja}.
        \end{itemize}
        \item Etapy podzielone na dwie części: \underline{twórczą} i \underline{weryfikacji}
        \item Ponowna praca, jeśli konieczna, jest wykonywana w kolejnych etapach - bardzo wysoki koszt błędów
        popełnionych we wstępnych etapach, adaptowanie zmian bardzo kosztowne.
        \item Koszty opracowania i akceptacji dokumentów są wysokie, powinien bvyć używany
        tylko jeśli wymagania są jasne i zrozumiałe.
        \item Marginalizacja roli klienta w procesie wytwarzania oprogramowania. Uzyskanie produktu zgodnego z wymaganiami
        silnie zależne od ich stabilności.
    \end{itemize}

    \subsubsection{Model V}
    \begin{figure}[H]
        \includegraphics[width=\linewidth]{model_v.png}
    \end{figure}

    \subsubsection{Model Ewolucyjny}
    \begin{table}[H]
        \begin{center}
            \begin{tabular}{ p{8cm} c }
                \begin{itemize}
                    \item pozwala później określić wymagania do projektowanego systemu,
                    \item prototyp pomaga kształcić przyszłego użytkownika,
                    \item prototyp podnosi koszty w krótszej perspektywie, ale w
                    dłuższej może je obniżać,
                    \item zwykle prototyp jest wyrzucany.
                \end{itemize}
                &
                \raisebox{-\totalheight}{\includegraphics[width=0.5\textwidth]{model_ewolucyjny.png}}
                \\
            \end{tabular}
        \end{center}
    \end{table}


    \subsubsection{Model iteracyjny}

    \begin{table}[H]
        \begin{center}
            \begin{tabular}{ p{8cm} c }
                \begin{itemize}
                    \item pozwala na wczesne wykrywanie błędów,
                    \item łączy iteracje z klasycznym modelem kaskadowym,
                    \item łatwość wprowadzania zmian,
                    \item wymogi klienta dotyczące harmonogramu mogą utrudnić korzystanie z tego
                    modelu,
                    \item problemy z oszacowaniem ryzyka.
                \end{itemize}
                &
                \raisebox{-\totalheight}{\includegraphics[width=0.5\textwidth]{model_iteracyjny.png}}
                \\
            \end{tabular}
        \end{center}
    \end{table}


    \subsubsection{Model spiralny}
    \begin{table}[H]
        \begin{center}
            \begin{tabular}{ p{8cm} c }
                \begin{itemize}
                    \item ciągłe monitorowanie i pomiar zmian,
                    \item zmiany poddawane są review użytkownika,
                    \item próba minimalizacji ryzyka niepowodzenia.
                \end{itemize}
                &
                \raisebox{-\totalheight}{\includegraphics[width=0.5\textwidth]{model_spiralny.png}}
                \\
            \end{tabular}
        \end{center}
    \end{table}

    \section{Standardy jakości}

    Odpowiedź na syndrom \textbf{LOOP} - \textbf{L}ate, \textbf{O}ver budget, \textbf{O}vertime, \textbf{P}oor quality.

    Minusy standaryzacji:
    \begin{itemize}
        \item Ważniejszy proces niż samo oprogramowanie,
        \item Spora cześć procesu jest fikcyjna, tworzenie dużej ilości dokumentacji,
        \item Dyscyplina zabija inicjatywę.
    \end{itemize}

    \subsection{CMM - Capability Maturity Model}
    \textbf{Ocenia proces wytwórczy} służacy do produkcji oprogramowania w skali pięciostopniowej - od \textbf{chaotycznego} (nic nie jest
    sterowane ani kontrolowane), aż do \textbf{ścisłego}, zdyscyplinowanego procesu uwzględniającego wszystkie potrzebne aspekty.

    Model CMM obejmuje \textbf{pięć aspektów}:
    \begin{itemize}
        \item Poziomy dojrzałości
        \item Kluczowe obszary procesowe
        \item Cele
        \item Atrybuty procesu
        \item Kluczowe praktywki
    \end{itemize}

    \subsubsection{Poziomy dojrzałości}
    \begin{table}[H]
        \begin{center}
            \begin{tabular}{ p{8cm} p{8cm} }
                \textbf{Poziom 1 - Wstępny}
                &
                \begin{itemize}
                    \item Działanie tymczasowe, doraźne.
                    \item Organizacja bez stabilnej technologii wytwarzania i utrzymywania produktów.
                    \item Zakres projektów zupełnie nieprzewidywalny.
                \end{itemize}
                \\

                \textbf{Poziom 2 - Powtarzalny}
                &
                \begin{itemize}
                    \item Dokumentowane standardy dokumentacji, szkoleń, utrzymywania.
                    \item w miarę ustabilizowane środowisko pracy i procedury zarządzania.
                \end{itemize}
                \\

                \textbf{Poziom 3 - Zdefiniowany}
                &
                \begin{itemize}
                    \item Spójny zbiór definicji i standardów na poziomie
                    organizacji realizującej projekt.
                    \item Wyodrębnienie w zespole specjalistów od realizacji
                    poszczególnych zadań, a organizacja dąży do wyposażenia ich
                    w niezbędną wiedzę i umiejętności.
                    \item Organizacja zaczyna na podstawie własnych doświadczeń
                    modyfikować sposób prowadzenia projektów, tak aby
                    maksymalnie odpowiadał jej specyfice.
                \end{itemize}
                \\

                \textbf{Poziom 4 - Zarządzany}
                &
                \begin{itemize}
                    \item W jakimś zdefiniowanym obszarze wyniki podejmowanych działań
                    przenoszą określone rezultaty, które można zmierzyć za
                    pomocą wcześniej zdefiniowanych metryk.
                    \item Zadania, których wykonanie nie generuje dużej liczby
                    błędów mogą być kontrolowane z mniejszą
                    częstotliwością, zaś obszary zdefiniowane jako
                    potencjalnie niebezpieczne np. w związku ze zmianą
                    technologii, mogą podlegać ściślejszej kontroli.
                \end{itemize}
                \\

                \textbf{Poziom 5 - Optymalizujący}
                &
                \begin{itemize}
                    \item Proces jest już tak dobrze zorganizowany i zarządzany, że
                    nie pozostaje nic innego, jak tylko dalsze podnoszenie
                    stawianych przed procesem wymagań.
                    \item Celem stawianym na tym poziomie jest optymalizacja i
                    dalsze ulepszanie procesu, zwiększanie jego
                    efektywności oraz wydajności.
                \end{itemize}
                \\
            \end{tabular}
        \end{center}
    \end{table}


    \subsection{ISO 9000}
    Wymaga \textbf{udokumentowania wszystkich procedur} związanych z wytwarzaniem oprogramowania.

    \begin{figure}[H]
        \includegraphics[width=\linewidth]{model_ISO.png}
    \end{figure}

    \begin{table}[H]
        \begin{center}
            \begin{tabular}{ p{8cm} p{8cm} }
                \textbf{Odpowiedzialność kierownictwa}
                &
                Kierownictwo:
                \begin{itemize}
                    \item odpowiada za właściwe funkcjonowanie organizacji,
                    \item ustala misję i politykę organizacji, określa cele,
                    \item opracowuje plan
                    działań do realizacji celów i przyznaje odpowiednie zasoby.
                \end{itemize}
                \\

                \textbf{Zarządzanie zasobami}
                &
                \begin{itemize}
                    \item Zespół procesów związanych z zasobami - ludzkimi, infrastrukturą, środowiskiem pracy.
                \end{itemize}
                \\

                \textbf{Realizacja wyrobu}
                &
                \begin{itemize}
                    \item Zespół procesów bezpośrednio związany z
                    realizacją wyrobu lub usługi.
                    \item Wejściem są wymagania klienta, a wyjściem jest
                    dostarczony wyrób lub usługa.
                \end{itemize}
                \\

                \textbf{Pomiary, analiza i doskonalenie}
                &
                \begin{itemize}
                    \item Procesy w organizacji i zadowolenie klienta
                    wymagają systematycznego monitoringu, analizy i
                    podejmowania działań doskonalących, aby wiedzieć
                    jak postrzega nas klient (zadowolenie) oraz jak
                    funkcjonują procesy w organizacji (zielona strzałka).
                \end{itemize}
                \\

                \textbf{Ciągłe doskonalenie} systemu zarządzania jakością
                &
                \begin{itemize}
                    \item Ciągłe zwiększanie skuteczności i efektywności w realizacji polityki,
                    strategii i celów organizacji.
                \end{itemize}
                \\
            \end{tabular}
        \end{center}
    \end{table}


    \section{Zwinne procesy wytwarzania oprogramowania}
    \textbf{Idea przepływu produktu przez system, podczas którego systematycznie zwiększana jest jego wartość.}\\

    Manifesto for Agile Software Development:
    \begin{itemize}
        \item Individuals and interactions $\rightarrow$ Teamwork and responsibility
        \item Working software $\rightarrow$ Business value
        \item Customer collaboration $\rightarrow$ Partnership elaboration
        \item Respodning to change $\rightarrow$ Prepare for change
    \end{itemize}

    Lightweight (XP, Scrum) or fuller (DSDM, AUP) approaches.

    \subsection{Programowanie ekstremalne - XP}
    Projekt informatyczny - \textbf{szczelny systemem czterech zmiennych: daty dostarczenia, kosztu, liczby
    defektów oraz niekompletności funkcji}.

    \begin{table}[H]
        \begin{center}
            \begin{tabular}{ c c }
                \raisebox{-\totalheight}{\includegraphics[width=0.5\textwidth]{model_xp.png}}
                &
                \raisebox{-\totalheight}{\includegraphics[width=0.5\textwidth]{xp_framework.png}}
                \\
            \end{tabular}
        \end{center}
    \end{table}

    \begin{itemize}
        \item brak fazy projektowania i dokumentacji,
        \item krótka perspektywa planowania,
        \item silne założenie, że klient pracuje cały czas z zespołem.
    \end{itemize}

    \textbf{Wartości}
    \begin{itemize}
        \item \textbf{Komunikacja} - przede wszystkim werbalna.
        \item \textbf{Prostota} - rozpoczynamy od najprostszego rozwiązania, spełniającego
        wymagania; refaktoryzacja pozwala na adaptacje oprogramowania do zmian.
        \item \textbf{Sprzężenie zwrotne} - obejmuje kilka aspektów (system, klient, zespół).
        \item \textbf{Odwaga} - potrzebna by: od razu produkować kod; refaktoryzować; wyrzucić zbędny kod.
        \item \textbf{Szacunek} - do pracy i czasu innych; między członkami zespołu.
    \end{itemize}

    \begin{table}[H]
        \begin{center}
            \begin{tabular}{ p{8cm} p{8cm} }
                \textbf{Struktura zespołu}
                &
                \begin{itemize}
                    \item \textbf{Role podstawowe}: programiści, klient,
                    \item \textbf{Role pomocnicze}: tester, coach, tracker.
                \end{itemize}
                \\

                \cmidrule(r){1-1}\cmidrule(l){2-2}
                \textbf{User Stories}
                &
                \begin{itemize}
                    \item opisują \textbf{funkcje systemu} z punktu widzenia użytkownika,
                    \item ważne by miały wartość dla klienta,
                    \item powinny być testowane.
                \end{itemize}
                \\

                \cmidrule(r){1-1}\cmidrule(l){2-2}
                \textbf{Gra planistyczna}
                &
                \begin{itemize}
                    \item \textit{pisanie} user story (klient),
                    \item \textit{oszacowanie} user story (informatycy),
                    \item \textit{dzielenie} user story/wybór zakresu iteracji (klient).
                \end{itemize}
                \\

                \cmidrule(r){1-1}\cmidrule(l){2-2}
                \textbf{Zapewnianie jakości}
                &
                \begin{itemize}
                    \item prostota,
                    \item unikanie optymalizacji,
                    \item Test Driven Development - TTD,
                    \item automatyczne testowanie,
                    \item refaktoryzacja.
                \end{itemize}
                \\

                \cmidrule(r){1-1}\cmidrule(l){2-2}
                \textbf{Testy akceptacyjne}
                &
                \begin{itemize}
                    \item pochodzą od klienta (w ten sposób dokładnie określa,
                    zachowanie systemu),
                    \item najlepiej gdy mogą być wykonywane automatycznie (tester).
                \end{itemize}
                \\

                \cmidrule(r){1-1}\cmidrule(l){2-2}
                \textbf{Programowanie parami}
                &
                \begin{itemize}
                    \item zaleca się, by całość kodu pisana była w parach,
                    \item częste zmiany w parach,
                    \item wspólny standard kodowania,
                    \item kod jest własnością całego zespołu,
                    \item niezbędny system kontroli wersji.
                \end{itemize}
                \\
            \end{tabular}
        \end{center}
    \end{table}

    \subsection{SCRUM}
    Metoda przy użyciu której ludzie mogą z powodzeniem rozwiązywać \textbf{złożone problemy
    adaptacyjne}, by w sposób produktywny i kreatywny wytwarzać produkty o najwyższej możliwej wartości.
    \begin{itemize}
        \item lekki;
        \item łatwy do zrozumienia;
        \item bardzo trudny do opanowania.
    \end{itemize}

    \textbf{Trzy filary} teorii SCRUMa:
    \begin{itemize}
        \item \textbf{Adaptacja} - powinna być \underline{ciągła}. Korekta musi być
        wykonana jak najszybciej, by ograniczyć dalsze następstwa problemów.
        \item \textbf{Przejrzystość} - wszystkie \underline{istotne aspekty} procesu
        muszą być \underline{widoczne} dla osób odpowiedzialnych za osiągane rezultaty.
        \item \textbf{Inspekcja} – poddawane \underline{regularnej} inspekcji są zarówno scrumowe
        artefakty jak i postępy prac.
    \end{itemize}

    \subsubsection{Role}
    \begin{table}[H]
        \begin{center}
            \begin{tabular}{ p{.5\textwidth} p{0.5\textwidth} }
                \textbf{Właściciel Produktu}
                &
                \begin{itemize}
                    \item odpowiedzialny za maksymalizację wartości produktu i pracy Zespołu
                    Deweloperskiego,
                    \item jedyną osoba zarządzająca Rejestrem Produktu, tzn:
                    \begin{itemize}
                        \item jasne artykułowanie elementów Rejestru Produktu, określanie
                        ich kolejności w sposób zapewniający osiąganie założonych celów i misji;
                        \item zapewnianie dostępności i przejrzystości Rejestru Produktu dla wszystkich i to, że dobrze opisuje czym
                        Zespół Scrumowy będzie się zajmował.
                    \end{itemize}
                \end{itemize}
                \\

                \cmidrule(r){1-1}\cmidrule(l){2-2}
                \textbf{Zespoł deweloperski}
                &
                \begin{itemize}
                    \item złożony z profesjonalistów (3-9 osób); samoorganizujący się, wielofunkcyjny.
                    \item ma za zadanie dostarczenie (na zakończenie
                    każdego Sprintu), gotowego do wydania Przyrostu produktu,
                    \item nie przewiduje tytułów innych niż „Deweloper”,
                    \item odpowiedzialność za wykonywaną pracę ponosi cały Zespół; brak podziału na podzespoły.
                \end{itemize}
                \\

                \cmidrule(r){1-1}\cmidrule(l){2-2}
                \textbf{Scrum Master}
                &
                \begin{itemize}
                    \item odpowiedzialny za to, by Scrum był rozumiany i stosowany,
                    \item upewnia się, że Zespół Scrumowy stosuje się do założeń teorii Scruma, jego praktyk i reguł postępowania.
                    \item wspiera zarówno Właściciela Produktu, jak i Zespól Deweloperski.
                \end{itemize}
                \\
            \end{tabular}
        \end{center}
    \end{table}

    \subsubsection{Artefakty}
    \begin{table}[H]
        \begin{center}
            \begin{tabular}{ p{.5\textwidth} p{0.5\textwidth} }
                \textbf{Rejestr Produktu}
                &
                uporządkowana lista wszystkiego,
                co może być potrzebne w produkcie oraz jedyne źródło wymaganych zmian.
                Odpowiedzialny za RP jest Właściciel Produktu.
                Elementy posiadają atrybuty: opis, kolejność i oszacowanie (estymację).
                \\

                \cmidrule(r){1-1}\cmidrule(l){2-2}
                \textbf{Rejestr Sprintu}
                &
                podzbiór elementów RP wybranych do Sprintu rozszerzony o plan
                dostarczenia Przyrostu produktu.
                RS definiuje pracę, jaką ZD wykona by przekształcić elementy
                RP w „Ukończony” Przyrost.
                RS jest dobrze widocznym, tworzonym w czasie rzeczywistym obrazem pracy, jaką ZD planuje wykonać w trakcie Sprintu.
                RS należy tylko i wyłącznie do ZD.
                \\

                \cmidrule(r){1-1}\cmidrule(l){2-2}
                \textbf{Monitorowanie postępów Sprintu}
                &
                możliwe w każdym momencie Sprintu (Codzienny Scrum).
                \\

                \cmidrule(r){1-1}\cmidrule(l){2-2}
                \textbf{Przyrost}
                &
                suma wszystkich elementów RP zakończonych podczas wszystkich spirntów.
                Na koniec Sprintu nowy Przyrost musi być „Ukończony”.
                \\

                \cmidrule(r){1-1}\cmidrule(l){2-2}
                \textbf{Definicja Ukończenia}
                &
                Aby zapewnić przejrzystość, wszyscy członkowie danego zespołu muszą mieć wspólne
                pojmowanie, co to znaczy, że praca jest skończona. W miarę dojrzewania Zespołu Scrumowego oczekuje się, że ich Definicja Ukończenia będzie
                zawierała coraz bardziej rygorystyczne kryteria zapewniania jeszcze wyższej jakości.
                \\
            \end{tabular}
        \end{center}
    \end{table}

    \subsubsection{Zdarzenia}
    \textbf{Cztery formalne punkty} (ograniczone czasowo, wprowadzajace regularność) przeprowadzania inspekcji i dokonania korekty (adaptacji) (każde oprócz Sprinut).


    \begin{table}[H]
        \begin{center}
            \begin{tabular}{ p{.4\textwidth} p{0.6\textwidth} }
                \textbf{Sprint} – serce Scruma
                &
                \begin{itemize}
                    \item stałe przez okres trwania prac ograniczenie czasowe ($\leq$ 1 mies)
                    \item podczas Sprintu wytwarzany jest Przyrost ukończonej,
                    używalnej i potencjalnie gotowej do wydania funkcjonalności,
                    \item niedozwolone są zmiany, które wpłyną na cel Sprintu,
                    \item niezmienny skład Zespołu Deweloperskiego i jego cel jakościowy.
                \end{itemize}
                \\

                \cmidrule(r){1-1}\cmidrule(l){2-2}
                \textbf{Przerwanie Sprintu}
                &
                \begin{itemize}
                    \item tylko Właściciel Produktu ma prawo to zrobić;
                    \item w przypadku dezaktualizacji celu Sprintu,
                    \item zużywa zasoby, bo powoduje przegrupowanie podczas kolejnego Planowania
                    Sprintu.
                \end{itemize}
                \\

                \cmidrule(r){1-1}\cmidrule(l){2-2}
                \textbf{Planowanie Sprintu} - 8h/mies
                &
                \begin{itemize}
                    \item Część pierwsza: \textit{Co będzie zrobione w tym Sprincie?}
                    Wejście:
                    \begin{itemize}
                        \item Rejestr Produktu;
                        \item ostatni przyrost;
                        \item przewidywana pojemność ZD;
                        \item ostatnie odczyty wydajności;
                    \end{itemize}
                    Wyjście:
                    \begin{itemize}
                        \item elementu Rejestru Produktu
                        wybrane do zaimplementowania;
                        \item cel Sprintu.
                    \end{itemize}
                    \item Część druga: \textit{Jak wybrana praca będzie wykonana?}
                    \begin{itemize}
                        \item zwykle rozpoczęcie od stworzenia projektu systemu i planu prac
                        niezbędnych do przetworzenia elementów Rejestru Produktu w działający Przyrost produktu.
                        \item zanim Planowanie Sprintu dobiegnie końca, ZD powinien móc wytłumaczyć Właścicielowi
                        Produktu i Scrum Masterowi, w jaki sposób ma zamiar pracować, organizując się samodzielnie, by osiągnąć Cel
                        Sprintu i wytworzyć oczekiwany Przyrost.
                    \end{itemize}
                \end{itemize}
                \\

                \cmidrule(r){1-1}\cmidrule(l){2-2}
                \textbf{Codzienny Scrum} - 15 min/d
                &
                \begin{itemize}
                    \item Co zostało wykonane od ostatniego potkania?
                    \item Co zostanie wykonane przed kolejnym spotkaniem?
                    \item Jakie przeszkody stoją na drodze?
                \end{itemize}
                \\

                \cmidrule(r){1-1}\cmidrule(l){2-2}
                \textbf{Przegląd Sprintu} - 4h na zakończenie Sprintu
                &
                \begin{itemize}
                    \item WP stwierdza, które funkcjonalności zostały
                    „Ukończone”, a które nie;
                    \item ZD omawia, co poszło dobrze w trakcie
                    Sprintu; jakie były problemy i jak je rozwiązano;
                    \item ZD prezentuje „Ukończoną” pracę i
                    odpowiada na pytania dotyczące Przyrostu,
                    \item WP omawia Rejestr Produktu w aktualnej
                    jego postaci. Przewiduje termin zakończenia prac.
                    \item Cala grupa omawia kolejne kroki.
                \end{itemize}
                \\

                \cmidrule(r){1-1}\cmidrule(l){2-2}
                \textbf{Retrospektywa Sprintu} - okazja do przeprowadzenia inspekcji
                swoich działań i opracowania planu usprawnień.
                &
                \begin{itemize}
                    \item Sprawdzenie, co działo się w ostatnim Sprincie, biorąc pod
                    uwagę ludzi, zależności, procesy i narzędzia;
                    \item Zidentyfikowanie i uporządkowanie istotnych elementów, które
                    sprawdziły się w działaniu oraz tych, które kwalifikują się do
                    poprawy;
                    \item Stworzenie planu wprowadzania w życie usprawnień sposobu
                    wykonywania pracy przez Zespół Scrumowy.
                \end{itemize}
                \\
            \end{tabular}
        \end{center}
    \end{table}


    \subsection{AGILE PM (DSDM Atern)}

    \begin{figure}[H]
        \includegraphics[width=\linewidth]{atern_approach.png}
    \end{figure}

    \textbf{PROCESS - PEOPLE - PRODUCTS - PRACTISES}
    \begin{itemize}
        \item Focus on the \textit{business need}
        \item Deliver \textit{on time}
        \item \textit{Collaborate}
        \item Never compromise \textit{quality}
        \item Build incrementally from \textit{firm foundations}
        \item Develop \textit{iteratively}
        \item \textit{Communicate continuously} and clearly
        \item Demonstrate \textit{control}
    \end{itemize}



    \subsubsection{Fazy projektu}
    \begin{figure}[H]
        \includegraphics[width=\linewidth, height=10cm]{agile_fazy.png}
    \end{figure}


    \begin{table}[H]
        \begin{center}
            \begin{tabular}{ p{.3\textwidth} p{0.7\textwidth} }
                \textbf{Pre-project}
                &
                \begin{itemize}
                    \item problem biznesowy; identyfikacja Business Sponsor i Business Visionary,
                    \item zakres, plan i zasoby na fazę Feasibility.
                \end{itemize}
                \\

                \textbf{Feasibility}
                &
                \begin{itemize}
                    \item ustalić wykonalność rozwiązania problemu biznesowego,
                    \item identyfikacja potencjalnych zysków; zarys możliwych podejść do rozwiązania,
                    \item pierwsze estymaty czasowe i kosztowe.
                \end{itemize}
                \\

                \textbf{Foundation}
                &
                \begin{itemize}
                    \item wysoko poziomowe wymagania,
                    \item identyfikacja wspieranych procesów biznesowych,
                    \item podstawy architektury systemu; sposób zapewnienia wysokiej jakości.
                \end{itemize}
                \\

                \textbf{Exploration}
                &
                \begin{itemize}
                    \item uszczegóławianie wymagań; iteracyjnie działające rozwiązanie,
                    \item zarys możliwych podejść do rozwiązania.
                \end{itemize}
                \\

                \textbf{Engineering}
                &
                \begin{itemize}
                    \item rozwijanie rozwiązania z fazy Exploration.
                \end{itemize}
                \\

                \textbf{Deployment}
                &
                \begin{itemize}
                    \item potwierdzenie wydajności rozwiązania,
                    \item dostarczenie (iteracyjnie) rozwiązania,
                    \item dostarczenie potrzebnej dokumentacji.
                \end{itemize}
                \\
            \end{tabular}
        \end{center}
    \end{table}




    \subsubsection{Role}
    \begin{table}[H]
        \begin{center}
            \begin{tabular}{ p{.3\textwidth} p{0.7\textwidth} }
                \textbf{Business Sponsor}
                &
                \begin{itemize}
                    \item najwyższy rangą w projekcie; zapewnia finansowanie i zasoby,
                    \item właściciel tzw. przypadku biznesowego.
                \end{itemize}
                \\


                \textbf{Business visionary}
                &
                \begin{itemize}
                    \item definiuje wizję projektu i komunikuje ją,
                    \item ma zapewnić współprace na wszystkich poziomach projektu,
                    \item wkład w najważniejsze wymagania; arbiter w przypadku sporów.
                \end{itemize}
                \\

                \textbf{Project manager}
                &
                \begin{itemize}
                    \item monitoruje postęp projektu; motywuje zespoły, zatrudnia specjalistów,
                    \item wysoko poziomowe planowanie harmonogramu, zarządzanie ryzykiem w projekcie.
                \end{itemize}
                \\

                \textbf{Technical coordination}
                &
                \begin{itemize}
                    \item definiuje środowisko pracy,
                    \item doradza w sprawach technicznych, pilnuje standardów,
                    \item zajmuje się wymaganiami niefunkcjonalnymi.
                \end{itemize}
                \\

                \textbf{Team Leader}
                &
                \begin{itemize}
                    \item skupiony na zespole, pilnuje dostarczania poszczególnych komponentów na czas,
                    \item raportuje postęp do PM, prowadzi spotkania zespołowe.
                \end{itemize}
                \\

                \textbf{Business Ambassador}
                &
                \begin{itemize}
                    \item rola biznesowa w zespole deweloperskim,
                    \item dzieli się perspektywa biznesową z zespołem, dostarcza scenariusze biznesowe,
                    \item tworzy dokumentacje użytkownika.
                \end{itemize}
                \\

                \textbf{Business Analyst}
                &
                \begin{itemize}
                    \item komunikacja między biznesem a zespołem deweloperskim,
                    \item dystrybucja i wstępna akceptacja dokumentów biznesowych.
                \end{itemize}
                \\

                \textbf{Solution Developer}
                &
                \begin{itemize}
                    \item skupiony na dostarczeniu rozwiązania,
                    \item modele potrzebne do dostarczenia rozwiązania, dokumentacja.
                \end{itemize}
                \\

                \textbf{Solution Tester}
                &
                \begin{itemize}
                    \item definiuje scenariusze testowe, test casy,
                    \item komunikuje wyniki testów do TL, pracuje z BAs nad testami akceptacyjnymi.
                \end{itemize}
                \\

            \end{tabular}
        \end{center}
    \end{table}


    \subsubsection{Produkty}

    Levels of priority - \textbf{MoSCoW}
    \begin{itemize}
        \item \textbf{M}ust Have
        \item \textbf{S}hould Have
        \item \textbf{C}ould Have
        \item \textbf{W}on’t Have this time
    \end{itemize}

    Fazy \textbf{TIMEBOX}u:
    \begin{itemize}
        \item \textbf{Kick-off} – krótka sesja, która ma pomoc zrozumieniu celu timeboxa,
        \item \textbf{Investigation} – szczegóły wszystkich produktów, które mamy wykonać,
        \item \textbf{Refinement} – kodowanie i testowanie,
        \item \textbf{Consolidation} – spinanie całości.
    \end{itemize}

    \textbf{Iterative development}:
    \begin{itemize}
        \item \textbf{Identify}: zespół definiuje cel
        \item \textbf{Plan}: kto powinien zrobić co
        \item \textbf{Evolve}: wykonywanie
        zaplanowanych czynności
        \item \textbf{Review}: sprawdzanie rezultatów
    \end{itemize}


    \begin{figure}[H]
        \includegraphics[width=\linewidth]{agile_iterations.png}
    \end{figure}


    \subsection{AUP - Agile Unified Process}

    \begin{itemize}
        \item uproszczona wersja Rational Unified Process,
        \item stosuje zwinne techniki takie jak TDD, refactoring,
        \item \textbf{seryjny w dużej skali, iteracyjny w małej}.
    \end{itemize}

    \begin{table}[H]
        \begin{center}
            \begin{tabular}{ c p{8cm} }
                \raisebox{-\totalheight}{\includegraphics[width=0.5\textwidth]{aup_phases.png}}
                &
                \textbf{Zasady AUP}
                \begin{itemize}
                    \item twój zespół wie, co robi;
                    \item prostota;
                    \item zwinność;
                    \item skupienie się na istotnych aktywnościach;
                    \item niezależność od narzędzi;
                    \item możliwość adaptacji.
                \end{itemize}
                \\
            \end{tabular}
        \end{center}
    \end{table}



    \subsection{KANBAN}

    \begin{table}[H]
        \begin{center}
            \begin{tabular}{ c p{8cm} }
                \raisebox{-\totalheight}{\includegraphics[width=0.5\textwidth]{kanban_vs_scrum.png}}
                &
                \begin{itemize}
                    \item \textbf{ciągły przepływ produktu przez system produkcyjny}.
                    \item podstawa systemów produkcyjnych Toyoty i pochodnych
                    \item \textbf{system pull} sterowany
                    jest przez \textbf{składane przez odbiorcę zamówienie}, a nie ogólny, arbitralny plan produkcji.
                    \item odnosi się do \textbf{etapowości procesu wytwarzania
                    oprogramowania}, przynajmniej trzy stany pracy — do zrobienia, w trakcie, gotowe.
                \end{itemize}
                \\
            \end{tabular}
        \end{center}
    \end{table}

    \textbf{Sześć reguł kanbana}:
    \begin{itemize}
        \item odbiorca przetwarza dokładnie tyle elementów, ile opisane
        jest na karcie kanban;
        \item dostawca wytwarza dokładnie tyle elementów, ile opisane jest
        na karcie kanban;
        \item żaden element nie jest wytwarzany lub przekazywany
        pomiędzy stanowiskami bez karty kanban;
        \item karta kanban musi towarzyszyć każdemu elementowi czy
        półproduktowi przetwarzanemu w ramach systemu;
        \item elementy wadliwe lub występujące w niewłaściwych ilościach,
        nigdy nie są przekazywane w dół procesu;
        \item limity obowiązujące na każdym z etapów (fizyczna ilość kart
        kanban) są stopniowo obniżane aby redukować zapasy i
        odkrywać nieefektywności procesów produkcji, dążąc do ich
        doskonalenia.
    \end{itemize}

    \subsubsection{Kanban vs Scrum}

    \begin{table}[H]
        \begin{center}
            \begin{tabular}{ | p{8cm} p{8cm} |}
                \toprule
                \multicolumn{2}{| p{16cm} |}{\textbf{Sposób pracy}}\\
                \toprule
                \textbf{Scrum} & \textbf{Kanban}\\
                \toprule

                Rytmiczność pracy & Płynność pracy\\
                \cmidrule(r){1-1}\cmidrule(l){2-2}
                Synchronizacja aktywnowści & Aktywności synchroniczne lub asynchronicznie\\
                \cmidrule(r){1-1}\cmidrule(l){2-2}
                Skupienie na celu, minimalizacja przełączania między zadaniami
                &
                Niski czas odpowiedzi systemu na zmiany\\
                \cmidrule(r){1-1}\cmidrule(l){2-2}
                Pewność realizacji aktywności związanych z Agile SD
                &
                Możliwość doboru czynności dopasowanych do środowiska\\
                \cmidrule(r){1-1}\cmidrule(l){2-2}
                Pełne zaangażowanie zespołu, wiedza ogólna i współodpowiedzialność
                &
                Możliwość pełnego wykorzystania specjalistów\\
                \cmidrule(r){1-1}\cmidrule(l){2-2}
                Trudność w pełnym wykorzystaniu zespołu ze względu na skokowy sposób pracy
                &
                Możliwość pełnego wykorzystania zespołu ze względu na płynny sposób pracy\\
                \cmidrule(r){1-1}\cmidrule(l){2-2}
                Niebezpieczeństwo przeładowania poprzez stosowanie źle wyznaczonych miar podczas planowania,
                penalizacji związanej z niedostarczeniem funkcjonalności
                &
                Niebezpieczeństwo przeładowania poprzez nadmierną optymalizację wykorzystania zespołu
                i restrykcyjności związanej z niedostarczeniem funkcjonalności\\
                \cmidrule(r){1-1}\cmidrule(l){2-2}
                Utrzymanie wydajności zespołu w dalszej perspektywie wymaga znacznego doświadczenia
                &
                Utrzymanie wydajności zespołu w dalszej perspektywie wymafa mniejszego doświadczenia.\\

                \bottomrule
            \end{tabular}
        \end{center}
    \end{table}

    \begin{table}[H]
        \begin{center}
            \begin{tabular}{ | p{8cm} p{8cm} |}
                \toprule
                \multicolumn{2}{| p{16cm} |}{\textbf{Definicja ukończenia}}\\
                \toprule
                \textbf{Scrum} & \textbf{Kanban}\\
                \toprule

                Wymaga, aby ukończenie zadania oznaczało dla wszystkich to samo
                &
                Sama metoda nie identyfikuje definicji ukończenia
                \\

                \cmidrule(r){1-1}\cmidrule(l){2-2}
                Bardziej szczegółowe implementacje korzystają z listy warunków jakie praca musi spełnić,
                aby może ją uznać za ukończoną
                &
                Bardziej szczegółowe implementacje określają warunki uznania zadania za ukończone poprzez
                przejście przez wszystkie procesy systemu
                \\
                \bottomrule
            \end{tabular}
        \end{center}
    \end{table}

    \begin{table}[H]
        \begin{center}
            \begin{tabular}{ | p{8cm} p{8cm} |}

                \toprule
                \multicolumn{2}{| p{16cm} |}{\textbf{Estymacja, planowanie i metryki}}\\
                \toprule
                \textbf{Scrum} & \textbf{Kanban}\\
                \toprule

                Określony sposób zarządzania zadaniami do realizacji w rejestrze produktu
                &
                Zadania do realizacji mogą pochodzić z różnych źródeł, a także być tworzone w ramach procesu
                \\

                \cmidrule(r){1-1}\cmidrule(l){2-2}
                Estymacja zadań prowadzona przez zespół, najczęściej relatywna
                &
                Brak wymagań względem estymacji, ewentualnie prostu podział typów zadań\\

                \cmidrule(r){1-1}\cmidrule(l){2-2}
                Estymacja zwiększa poziom zrozumienia zadań przez cały zespół
                &
                Brak konieczności poświęcania czasu na szczegółową estymację zadań\\

                \cmidrule(r){1-1}\cmidrule(l){2-2}
                Planowanie jako ilość pracy realizowanej w trakcie jednej iteracji
                &
                Planowanie oparte o przewidywany czas zakończenia zadania\\

                \cmidrule(r){1-1}\cmidrule(l){2-2}
                Zespół zobligowany do realizacji całości zaplanowanej pracy w trakci iteracji
                &
                Wykrywanie zadań przekraczających średni czas realizacji\\

                \cmidrule(r){1-1}\cmidrule(l){2-2}
                Zespół bierze czynny udział w planowaniu pracy
                &
                Zespół niekoniecznie musi brać udział w planowaniu pracy\\

                \cmidrule(r){1-1}\cmidrule(l){2-2}
                Postęp prac w ramach iteracji jest monitorowan na wykresach spalania
                &
                Postęp prac monitorowany na tablicy kanban oraz poprzez analizę średnich czasów wykonania\\

                \cmidrule(r){1-1}\cmidrule(l){2-2}
                Velocity - jedna miara dotycząca różnych zadań
                &
                Lead time może być określany dla zadań o różnej złożoności\\

                \cmidrule(r){1-1}\cmidrule(l){2-2}
                Velocity - określa ilość pracy w okresie czasu
                &
                Lead time - określa czas wykonania pewnej ilości pracy w postaci jednego zadania.\\

                \cmidrule(r){1-1}\cmidrule(l){2-2}
                Diagram zmiany velocity & Diagram zmiany lead time\\

                \cmidrule(r){1-1}\cmidrule(l){2-2}
                Brak konieczności posiadania zdefiniowanego przepływu zadań w ramach iteracji. Jeśli jest zdefiniowany
                można korzystać z Cumulative flow diagram
                &
                Cumulative flow diagram udostępniający informacje o pracy w toku i wpływie decyzji na lead time w sposób ciągły\\

                \cmidrule(r){1-1}\cmidrule(l){2-2}
                Możliwość planowania pracy w dalszym terminie
                &
                Możliwość gwarantowania czasu obsługi zadania\\

                \cmidrule(r){1-1}\cmidrule(l){2-2}
                Możliwość analizowania postępu w dalszym terminie
                &
                Dostosowanie procesu charakterystyki obsługiwanych zadań i warunków nałożonych na czas ich realizacji\\

                \bottomrule
            \end{tabular}
        \end{center}
    \end{table}





    \subsection{SCRUM + KANBAN = SCRUM-BAN}
    Kiedy używać Scrum-bana?
    \begin{itemize}
        \item W projektach typu maintenance
        \item W projektach typu helpdesk
        \item W projektach z często dorzucanymi User stories
        lub często zgłaszanymi bledami
    \end{itemize}


    \begin{table}[H]
        \begin{center}
            \begin{tabular}{| p{3cm} | p{6cm} p{6cm} |}
                \toprule
                & \textbf{Scrum} & \textbf{Scrumban}\\
                \toprule

                \cmidrule(r){1-1}\cmidrule(rl){2-2}\cmidrule(l){3-3}
                \textbf{Board/Artifacts} & board, backlogs, burn-downs & board only\\

                \cmidrule(r){1-1}\cmidrule(rl){2-2}\cmidrule(l){3-3}
                \textbf{Ceremonies} & daily scrum, sprint planning, sprint review, sprint retrospective
                & daily scrum (planning, review and retrospective as needed)\\

                \cmidrule(r){1-1}\cmidrule(rl){2-2}\cmidrule(l){3-3}
                \textbf{Iterations} & yes (sprints) & no (continuous flow)\\

                \cmidrule(r){1-1}\cmidrule(rl){2-2}\cmidrule(l){3-3}
                \textbf{Estimation} & yes & no (similar size)\\

                \cmidrule(r){1-1}\cmidrule(rl){2-2}\cmidrule(l){3-3}
                \textbf{Teams} & mus be cross-functional & can be specialized\\

                \cmidrule(r){1-1}\cmidrule(rl){2-2}\cmidrule(l){3-3}
                \textbf{Roles} & Product Owner, Scrum Master, Team & Team $+$ need roles\\

                \cmidrule(r){1-1}\cmidrule(rl){2-2}\cmidrule(l){3-3}
                \textbf{Teamwork} & collaborative as needed by task & swarming to achieve goals\\

                \cmidrule(r){1-1}\cmidrule(rl){2-2}\cmidrule(l){3-3}
                \textbf{WIP} & controlled by sprint content & controlled by workflow state\\

                \cmidrule(r){1-1}\cmidrule(rl){2-2}\cmidrule(l){3-3}
                \textbf{Changes} & should wait for the next sprint & added as needed on the to-do board\\

                \cmidrule(r){1-1}\cmidrule(rl){2-2}\cmidrule(l){3-3}
                \textbf{Product Backlog} & list of prioritized end estimated stories & just in time cards\\

                \cmidrule(r){1-1}\cmidrule(rl){2-2}\cmidrule(l){3-3}
                \textbf{Impediments} & dealt with immediately & avoided\\

                \bottomrule
            \end{tabular}
        \end{center}
    \end{table}

    \section{Wymagania}
    \begin{itemize}
        \item Wymagania to \textbf{opis funkcji} (usług) i ograniczeń dla systemu.
        \item Wymagania nie opisują jak system ma działać, a \textbf{co ma
        wykonywać}.
        \item Definiowane na \textbf{wczesnych etapach rozwoju} systemu jako specyfikacja tego, co ma być
        implementowane.
        \item Inżynieria wymagań to proces pozyskiwania, analizowania, dokumentowania oraz weryfikowania
        wymagań dla projektowanego systemu.

    \end{itemize}

    \subsection{Klasyfikacja wymagań}
    \begin{itemize}
        \item \textbf{Funkcjonalne} - czynność, zadanie.
        \item \textbf{Pozafunkcjonalne} - technikalia mierzone metrykami.
    \end{itemize}

    \textbf{Klasyfikacja wymagań - FURPS} - \textbf{F}unctionality, \textbf{U}sability, \textbf{R}eliability,
    \textbf{P}erformance, \textbf{S}ecurity.

    \subsubsection{Wymagania funkcjonalne - „System powinien\dots”}
    \begin{itemize}
        \item \textbf{Zalety}: łatwość spisywania,
        \item \textbf{Wady}: słaba czytelność, trudne sprawdzanie kompletności i spójności.
        \item \textbf{Przypadki użycia}:  łatwość spisywania, czytelność, łatwość zrozumienia; forma ustrukturalizowana.
        \item \textbf{Historyjki użytkownika} - Who? What? Why?
    \end{itemize}

    Cecha \textbf{INVEST}:
    \begin{itemize}
        \item \textbf{Independent} - zależności powodują problem z estymacją),
        \item \textbf{Negotiable},
        \item \textbf{Valuable},
        \item \textbf{Estimable},
        \item \textbf{Small} (jeden sprint),
        \item \textbf{Testable}.
    \end{itemize}

    \subsubsection{Wymagania pozafunkcjonalne}
    \begin{itemize}
        \item Ograniczenia usług lub funkcji, np. czasowe, procesu rozwoju oprogramowania, standardy.
        \item Każda cecha to \textbf{zbiór atrybutów}.
        \item Stanowią \textbf{niezbędne uzupełnienie wymagan funkcjonalnych} dla oprogramowania,
        \item Problemy z oprogramowaniem wskazują na silną potrzebę precyzyjnego definiowania atrybutów
        (charakterystyk) dla tworzonych produktów programistycznych.
    \end{itemize}


    \begin{table}[H]
        \begin{center}
            \begin{tabular}{  p{8cm} p{8cm} }
                \textbf{Niezawodność} - zdolność do spełnienia i utrzymania
                określonych wymagań stabilności, przy spełnieniu określonych
                warunków oraz w określonych ramach czasowych.
                &
                \begin{itemize}
                    \item Dojrzałość
                    \item Odporność na błędy
                    \item Zdolność do odtworzenia
                \end{itemize}
                \\

                \cmidrule(r){1-1}\cmidrule(l){2-2}

                \textbf{Wydajność} - opisuje powiązania miedzy poziomem wydajności oprogramowania, a
                wykorzystywanymi zasobami przy spełnieniu określonych warunków.
                &
                \begin{itemize}
                    \item Wykorzystanie czasu
                    \item Wykorzystanie zasobów
                \end{itemize}
                \\

                \cmidrule(r){1-1}\cmidrule(l){2-2}

                \textbf{Użyteczność} - opisuje nakład pracy niezbędny do swobodnego posługiwania się oprogramowaniem.
                &
                \begin{itemize}
                    \item Łatwość zrozumienia
                    \item Łatwość nauki
                    \item Operatywność
                \end{itemize}
                \\

                \cmidrule(r){1-1}\cmidrule(l){2-2}

                \textbf{Łatwość konserwacji} - opisuje nakład pracy niezbędny do wprowadzenia zmian do oprogramowania.
                &
                \begin{itemize}
                    \item Łatwość analizy
                    \item Łatwość wprowadzania zmian
                    \item Stabilność
                    \item Łatwość testowania
                \end{itemize}
                \\

                \cmidrule(r){1-1}\cmidrule(l){2-2}

                \textbf{Przenośność} - opisuje zdolność oprogramowania do przenoszenia między różnymi środowiskami/platformami.
                &
                \begin{itemize}
                    \item Łatwość adaptacji
                    \item Zgodność
                    \item Łatwość instalacji
                    \item Łatwość zastąpienia
                \end{itemize}
                \\


            \end{tabular}
        \end{center}
    \end{table}




    \subsection{Analiza wymagań/analiza obiektowa}
    \begin{itemize}
        \item Celem jest stworzenie modelu systemu, zwanego \textbf{modelem analitycznym}.
        \item Wysiłek uczestników projektu skupia się na strukturalizowaniu i formalizowaniu zabranych
        wcześniej wymagań.
    \end{itemize}

    \begin{table}[H]
        \begin{center}
            \begin{tabular}{ c p{8cm} }
                \raisebox{-\totalheight}{\includegraphics[width=0.5\textwidth]{analiza_wymagan.png}}
                &
                \begin{itemize}
                    \item \textbf{Model analityczny} – reprezentuje tworzony system z perspektywy użytkownika; opis co system powinien robić.
                    \item \textbf{Analityczny model obiektowy} – odzwierciedla indywidualne koncepcje korzystania z systemu, ich właściwości i relacje między nimi (diagramy klas).
                    \item \textbf{Model dynamiczny} - koncentruje się na zachowaniu systemu(diagramy sekwencji i stanów).
                    \item \textbf{Obiekty encji} – reprezentują trwałą informację potwarzaną przez system.
                    \item \textbf{Obiekty brzegowe} – odzwierciedlają interakcje między aktorami a systemem.
                    \item \textbf{Obiekty sterujące} – odpowiedzialne są za realizację przypadków użycia.
                    \item \textbf{Relacja dziedziczenia} umożliwia hierarchiczne organizowanie koncepcji.
                    \item \textbf{Generalizowanie} - aktywność identyfikowania abstrakcyjnych koncepcji na podstawie przykładów i konkretyzacji.
                    \item \textbf{Specjalizowanie} - aktywność odwrotna, czyli identyfikowanie koncepcji bardziej specyficznych na podstawie koncepcji wysokopoziomowej.
                \end{itemize}
                \\
            \end{tabular}
        \end{center}
    \end{table}


    \section{Projektowanie systemu}
    \textbf{Transformowanie modelu analitycznego w model projektu systemu.}

    Etapy projektowania systemu:
    \begin{itemize}
        \item rozpoznawanie celów projektowych,
        \item projektowanie wstępnych dekompozycji,
        \item doskonalenie dekompozycji stosownie do celów projektowych.
    \end{itemize}

    \begin{figure}[H]
        \includegraphics[width=\linewidth]{projekt_systemu.png}
    \end{figure}

    \subsection{Podstawowe pojęcia i koncepcje.}
    \begin{itemize}
        \item \textbf{Podsystem} - wymienna część systemu, posiadającą dobrze zdefiniowane interfejsy i
        hermetyzującą stan oraz zachowanie składających się na nią klas.
        \item Dwa główne typy komponentów: \textbf{logiczny i fizyczny}.
        \item \textbf{Usługa} jest zbiorem powiązanych operacji podporządkowanych realizacji wspólnego
        celu.
        \item \textbf{Sprzężeniem} w zbiorze podsystemów nazywamy stopień ich \textbf{wzajemnego uzależnienia}. (MINIMALIZACJA)
        \item \textbf{Spoistość} podsystemu jest miara \textbf{uzależnienia jego własnych klas}. (MAKSYMALIZACJA)
        \item \textbf{Warstwa} - zgrupowanie podsystemów oferujących powiązane usługi.
        \item Efektem \textbf{dekompozycji hierarchicznej} jest uporządkowany zbiór warstw.
        \item \textbf{Architektury warstwowa}: otwarta i zamknięta (np ISO/OSI, TCP/IP).
    \end{itemize}


    \subsection{Wzorce architektoniczne - poziom integracji komponentów}

    \subsubsection{MVC: model-widok-kontroler}
    Model zawiera korowa funkcjonalność. Widoki wyświetlają funkcjonalności. Kontroler obsługuje żądanie użytkownika. Kontroler z widokami tworzą UI aplikacji.

    Zastosowania: Smalltalk, Java/Swing.

    \begin{figure}[H]
        \includegraphics[width=.5\linewidth]{mvc.png}
        \includegraphics[width=.5\linewidth]{mvc-struktura.png}
    \end{figure}



    \subsubsection{PAC: prezentacja-abstrakcja-kontrola}
    Hierarchie kooperujących agentów,podzielonych na trzy komponenty: prezentacji, abstrakcji kontroli.

    Zastosowania: Network Trafic Management (gathering traffic datha, displaying various user-configurable
    views of the whole network).

    \begin{figure}[h]
        \includegraphics[width=.5\linewidth]{pac.png}
        \includegraphics[width=.5\linewidth]{pac-struktura.png}
    \end{figure}



    \subsubsection{Architektura filtry i potoki}

    Pozwala na uporządkowanie systemu, który przetwarza strumienie danych. Każdy krok przetwarzania jest zamknięty w filtrze.
    Dane są przesyłane za pomocą potoków. Każdy z podsystemów realizuje przetwarzanie danych otrzymanych od innych podsystemów.

    Zastosowania: Unix, WEB, Servlet, Numerical Analysis (filters and data extractions).

    \begin{figure}[h]
        \includegraphics[width=.5\linewidth]{fip.png}
        \includegraphics[width=.5\linewidth]{fip_struktura.png}
    \end{figure}




    \subsubsection{Tablica(blackboard)}
    Użyteczna w systemach, gdzie nie są znane deterministyczne rozwiązania danego problemu. W przypadku tablicy kilka wyspecjalizowanych
    systemów łączy swoja wiedze w taki sposób, żeby stworzyć częściowe lub przybliżone rozwiązanie problemu.

    Zastosowania: working memory, repository data.

    \begin{figure}[h]
        \includegraphics[width=.5\linewidth]{tablica.png}
    \end{figure}



    \subsubsection{Broker}
    Pozwala na uporządkowanie rozproszonych systemów podzielonych na komponenty współpracujące ze sobą za pomocą zdalnego wywoływania
    serwisu. Komponent brokera odpowiedzialny jest za koordynację komunikacji.

    \begin{figure}[h]
        \includegraphics[width=.5\linewidth]{broker.png}
        \includegraphics[width=.5\linewidth]{broker_struktura.png}
    \end{figure}

    \subsubsection{Reflection}
    Dostarcza mechanizm pozwalający na dynamiczną zmianę zachowania i struktury systemu.
    \begin{figure}[h]
        \includegraphics[width=.5\linewidth]{ref.png}
        \includegraphics[width=.5\linewidth]{ref_struktura.png}
    \end{figure}

    Zastosowania: WWW.

    \subsubsection{Sieciowe}
    \begin{itemize}
        \item \textbf{Architektura klient-serwer} - podział systemu na dostawce usług (serwer) oraz ich odbiorców (klientów).
        \item \textbf{Architektura peer-to-peer} - każdy z podsystemów może spełniać obie funkcje (klient/serwer).

    \end{itemize}

    \subsubsection{Wzorce architektoniczne - wady}
    \begin{itemize}
        \item Patterns do not lead to direct code reuse.
        \item Individual Patterns are deceptively simple.
        \item Composition of different patterns can be very complex.
        \item Teams may suffer from pattern overload.
        \item Patterns are validated by experience and discussion
        rather than by automated testing.
        \item Integrating patterns into a software development
        process is a human-intensive activity.
    \end{itemize}


    \section{Projektowanie obiektów}
    Ma na celu \textbf{wypełnienie luki między obiektami dziedziny aplikacyjnej a komponentami} wybranymi na etapie projektowania systemu.


    \begin{figure}[h]
        \includegraphics[width=\linewidth]{projektowanie_obiektow.png}
    \end{figure}

    \textbf{Etapy projektowania obiektów}
    \begin{itemize}
        \item wykorzystanie gotowych rozwiązań, którymi są zarówno
        gotowe produkty (komponenty) jak i wzorce projektowe;
        \item specyfikowanie usług;
        \item restrukturyzacja modelu obiektowego;
        \item optymalizacja modelu obiektowego;
    \end{itemize}

    \begin{figure}[H]
        \includegraphics[width=\linewidth]{subsystem.png}
    \end{figure}

    Koncepcje wielokrotnego wykorzystywania gotowych rozwiązań:
    \begin{itemize}
        \item \textbf{obiekty aplikacyjne} - reprezentują koncepcje problemowe związane z tworzonym systemem.
        \item \textbf{obiekty realizacyjne} - reprezentują komponenty nie mające odpowiedników w
        dziedzinie aplikacyjnej, na przykład bazy danych czy obiekty interfejsu użytkownika.
        \item \textbf{dziedziczenie implementacyjne} - ma miejsce jeśli sięgamy po dziedziczenie z zamiarem wykorzystania
        gotowego kodu, mimo różnic koncepcyjnych pomiędzy powiązanymi klasami.
        \item \textbf{dziedziczenie specyfikacyjne} - ma odzwierciedlenie w taksonomii klas (reprezentuje podtypowanie).
        \item \textbf{delegowanie implementacji} - zamiast implementować set jako nadpisywanie metod hashtable, implementujemy go jako set korzystajacy z instancji hashtable z własnymi metodami.
        Rozwiązuje problemy dziedziczenia implementacyjnego: rozszerzalność, podtypowanie.
        \item \textbf{zasada zastępowania Liskov} - \textit{'Jeśli obiekt klasy S może stać się substytutem obiektu klasy T w
        dowolnym miejscu kodu, w którym oczekiwany jest obiekt klasy T, to klasa S jest podtypem klasy T.'}
        \item \textbf{wzorce projektowe} (obiektowe);
    \end{itemize}



    \subsection{Wzorce projektowe - poziom interakcji między klasami}
    \textbf{Wzorzec opisuje problem, który powtarza się wielokrotnie w danym środowisku, oraz podaje istotę
    jego rozwiązania.}

    \begin{itemize}
        \item Czy typowe problemy można rozwiązać w powtarzalny sposób?
        \item Czy te problemy można przedstawić w sposób abstrakcyjny, tak aby były pomocne
        w tworzeniu rozwiązań w róznych konkretnych kontekstach?
    \end{itemize}

    \begin{itemize}
        \item \textbf{Wzorce kreacyjne}
        \begin{itemize}
            \item abstrakcyjne metody tworzenia obiektów,
            \item uniezależnienie systemu od sposobu tworzenia obiektów.
        \end{itemize}
        \item \textbf{Wzorce strukturalne}
        \begin{itemize}
            \item sposób wiązania obiektów w struktury,
            \item właściwe wykorzystanie dziedziczenia i kompozycji.
        \end{itemize}
        \item \textbf{Wzorce behawioralne}
        \begin{itemize}
            \item algorytmy i przydział odpowiedzialności,
            \item opis przepływu kontroli i interakcji.
        \end{itemize}
    \end{itemize}

    \subsection{Koncepcje specyfikowania interfejsów}
    \begin{itemize}
        \item implementator (realize class), ekstender (refine class) i użytkownik (use class) klasy,
        \item typy, sygnatury (wektory/krotki typów parametrów i typu wyniku) i widzialność (public, private, protected, packet),
        \item kontrakty: niezmienniki, warunki wstępne i warunki końcowe,
        \item język OCL (Object Constraint Language) – ograniczenia, zbiory, wielozbiory i ciągi; kwantyfikatory.
    \end{itemize}

    \subsection{Aktywności specyfikowania interfejsów}
    \begin{itemize}
        \item identyfikowanie brakujących atrybutów i operacji;
        \item definiowanie widzialności i sygnatur;
        \item specyfikowanie kontraktów;
        \item dziedziczenie kontraktów;
    \end{itemize}



    \subsection{SOLID}

    \begin{itemize}
        \item \textbf{Single responsibility principle}
        \begin{itemize}
            \item Klasa powinna mieć pojedyńczą odpowiedzialność.
            \item Nigdy nie powinien istnieć więcej niż jeden powód do modyfikacji klasy.
            \item Im mniejsza i bardziej wyspecyfikowana klasa tym łatwiej ją nazwać.
            \item Łatwiejsze wprowadzanie zmian,testowanie i naprawa
        \end{itemize}
        Jak rozpoznać naruszenie SRP?
        \begin{itemize}
            \item Ilość linii kodu ( Class:LOC > 250),
            \item Za dużo zależności, słaba spojność, dużo zagnieżdżeń,
            \item Opis lub nazwa wymaga “i”,
            \item Wymaga skomplikowanych testów,
            \item Modyfikacja może zepsuć inne testy.
        \end{itemize}
        \item \textbf{Open/closed principle}
        \begin{itemize}
            \item klasa powinna być otwarta na rozbudowę, ale zamknięta do jej własnej modyfikacji,
            \item możemy dodawać nowe pola i metody, ale bez zmiany w wewnętrznej strukturze,
            \item zmiana istniejącej struktury może mieć wpływ na inne elementy,
            \item hermetyzacja, dziedziczenie, polimorfizm, delegaty,
            \item unikamy instrukcji warunkowych.
        \end{itemize}
        \item \textbf{Liskov substitution principle}
        \begin{itemize}
            \item 'Jeśli obiekt klasy S może stać się substytutem obiektu klasy T w
            dowolnym miejscu kodu, w którym oczekiwany jest obiekt klasy T, to klasa S jest podtypem klasy T.'
        \end{itemize}
        \item \textbf{Interface segregation principle}
        \begin{itemize}
            \item Kilka konkretnych interfejsów jest lepszych niż jeden ogólny,
            \item Związki między klasami powinny być ograniczone do minimum,
            \item Klient klasy powinien mieć dostep tylko do tyh składowych klasy, których rzeczywiście potrzebuje,
            \item Moduły wysokiego poziomu nie powinny zależeć od modułów niskopoziomowych,
            \item Obie grupy modułów powinny zależeć od abstrakcji.
        \end{itemize}
        \item \textbf{Dependency inversion principle} - zasada odwracania zależności.
        \begin{itemize}
            \item Software powinien zależeć od abstrakcji a nie od konkretyzacji,
            \item 'Hollywood Principle' - don't call us, we'll call you!.
        \end{itemize}
    \end{itemize}


    \subsection{Wybrane wzorce kreacyjne}

    \begin{table}[H]
        \begin{center}
            \begin{tabular}{  p{8cm} c  }
                \toprule
                Wzorzec & Schemat \\

                \cmidrule(r){1-1}\cmidrule(l){2-2}
                \textbf{Singleton}
                \begin{itemize}
                    \item Zapewnienie, że \textbf{klasa posiada jedną instancję} wewnątrz całej aplikacji
                    \item Stworzenie punktu dostępowego do tej instancji
                \end{itemize}
                &
                \raisebox{-\totalheight}{\includegraphics[width=0.5\textwidth, height=60mm]{singleton.png}}
                \\

                \cmidrule(r){1-1}\cmidrule(l){2-2}
                \textbf{Factory method}
                \begin{itemize}
                    \item Zdefiniowanie \textbf{interfejsu do tworzenia obiektów}
                    \item Umożliwienie przekazania odpowiedzialności za tworzenie obiektów do podklas
                    \item Umożliwienie wyboru klasy i konstruktora użytego do utworzenia obiektu
                \end{itemize}
                &
                \raisebox{-\totalheight}{\includegraphics[width=0.5\textwidth, height=60mm]{fac-met.png}}
                \\

                \cmidrule(r){1-1}\cmidrule(l){2-2}
                \textbf{Builder}
                \begin{itemize}
                    \item \textbf{Odseparowanie sposobu reprezentacji i metody konstrukcji} złożonych struktur obiektowych
                    \item Wykorzystanie jednego mechanizmu konstrukcyjnego do tworzenia struktur o różnej reprezentacji
                \end{itemize}
                &
                \raisebox{-\totalheight}{\includegraphics[width=0.5\textwidth, height=60mm]{builder.png}}
                \\


                \bottomrule
            \end{tabular}
        \end{center}
    \end{table}


    \subsection{Wybrane wzorce strukturalne}

    \begin{table}[H]
        \begin{center}
            \begin{tabular}{  p{8cm} c  }
                \toprule
                Wzorzec & Schemat \\

                \cmidrule(r){1-1}\cmidrule(l){2-2}
                \textbf{Adapter}
                \begin{itemize}
                    \item Umożliwia \textbf{współpracę obiektów o niezgodnych typach}
                    \item Tłumaczy protokoły obiektowe
                \end{itemize}
                &
                \raisebox{-\totalheight}{\includegraphics[width=0.5\textwidth, height=60mm]{adapter.png}}
                \\

                \cmidrule(r){1-1}\cmidrule(l){2-2}

                \textbf{Proxy}
                \begin{itemize}
                    \item Dostarcza \textbf{zamiennik obiektu} w celu jego kontroli i ochrony
                    \item Przezroczyste odsuniecie inicjalizacji obiektu w czasie
                \end{itemize}
                &
                \raisebox{-\totalheight}{\includegraphics[width=0.5\textwidth, height=60mm]{proxy.png}}
                \\

                \cmidrule(r){1-1}\cmidrule(l){2-2}
                \textbf{Fasada}
                \begin{itemize}
                    \item Dostarczenie \textbf{jednorodnego interfejsu wyższego poziomu} do zbioru różnych interfejsów w systemie
                    \item Ukrycie złożoności podsystemów przed klientem
                \end{itemize}
                &
                \raisebox{-\totalheight}{\includegraphics[width=0.5\textwidth, height=60mm]{fasada.png}}
                \\

                \bottomrule
            \end{tabular}
        \end{center}
    \end{table}


    \subsection{Wybrane wzorce behawioralne}

    \begin{table}[H]
        \begin{center}
            \begin{tabular}{  p{8cm} c  }
                \toprule
                Wzorzec & Schemat \\

                \cmidrule(r){1-1}\cmidrule(l){2-2}
                \textbf{Obserwator}
                \begin{itemize}
                    \item Tworzy \textbf{zależność typu jeden-wiele} pomiędzy obiektami
                    \item \textbf{Informacja o zmianie} stanu wyróżnionego obiektu jest \textbf{przekazywana wszystkim pozostałym obiektom}
                \end{itemize}
                &
                \raisebox{-\totalheight}{\includegraphics[width=0.5\textwidth, height=60mm]{obserwator.png}}
                \\

                \cmidrule(r){1-1}\cmidrule(l){2-2}
                \textbf{Command}
                \begin{itemize}
                    \item \textbf{Hermetyzacja poleceń} do wykonania w postaci obiektów
                    \item Umożliwienie \textbf{parametryzacji klientów} obiektami poleceń
                    \item Wsparcie dla \textbf{poleceń odwracalnych}
                \end{itemize}
                &
                \raisebox{-\totalheight}{\includegraphics[width=0.5\textwidth, height=60mm]{command.png}}
                \\

                \cmidrule(r){1-1}\cmidrule(l){2-2}
                \textbf{Chain of responsibility}
                \begin{itemize}
                    \item \textbf{Usunięcie powiązania pomiędzy nadawcą i odbiorcą} żądania
                    \item Umożliwienie wielu obiektom obsługi żądania
                \end{itemize}
                &
                \raisebox{-\totalheight}{\includegraphics[width=0.5\textwidth, height=60mm]{ch-o-r.png}}
                \\

                \cmidrule(r){1-1}\cmidrule(l){2-2}
                \textbf{Iterator}
                \begin{itemize}
                    \item Umożliwienie \textbf{sekwencyjnego dostępu} do elementów kolekcji bez ujawniania jej wewnętrznej implementacji
                \end{itemize}
                &
                \raisebox{-\totalheight}{\includegraphics[width=0.5\textwidth, height=60mm]{iterator.png}}
                \\

                \bottomrule
            \end{tabular}
        \end{center}
    \end{table}


    \subsection{Implementacja wzorców projektowych}
    Implementacja to \textbf{transformowanie modelu w kod źródłowy}.

    \begin{figure}[H]
        \includegraphics[width=\linewidth]{wzorce.png}
    \end{figure}

    \subsubsection{Transformacja}
    \begin{itemize}
        \item powinna dotyczyć tylko jednego, ściśle określonego kryterium,
        \item musi mieć charakter lokalny, powinna być izolowana od innych zmian,
        \item musi być poddana weryfikacji.
    \end{itemize}

    \begin{table}[H]
        \begin{center}
            \begin{tabular}{ p{8cm} p{8cm} }
                \item \textbf{Transformacja modelu}
                \begin{itemize}
                    \item ograniczona jest do samego modelu
                    \item celem jest uproszczenie lub zoptymalizowanie istniejącego modelu
                \end{itemize}
                &
                \item \textbf{Inżynieria postępująca}
                \begin{itemize}
                    \item tworzenie szablonów kodu źródłowego odpowiadającego modelowi obiektowemu
                \end{itemize}\\
            \end{tabular}
        \end{center}
    \end{table}

    \textbf{Najczęściej wykonywane} aktywności (transformacje):
    \begin{itemize}
        \item \textbf{optymalizowanie modelu} obiektowego,
        \item odwzorowywanie \textbf{skojarzeń w kolekcje},
        \item odwzorowywanie \textbf{kontraktów w wyjątki},
        \item odwzorowywanie modelu obiektowego w \textbf{schematy bazy danych}.
    \end{itemize}


    \subsubsection{Paradygmat programowania}
    \begin{itemize}
        \item wzorzec, \textbf{najogólniejszy model}, jako wzorcowy przykład,
        \item \textbf{zbiór pojęć} i teorii tworzących \textbf{podstawy} danej nauki.
    \end{itemize}


    \textbf{Podstawowe założenia}:
    \begin{itemize}
        \item \textbf{Abstrakcja} - system jako układ obiektów rozpatrywanych jako modele
        abstrakcyjnego elementu, które mogą:
        \begin{itemize}
            \item opisywać i zmieniać swój stan,
            \item komunikować się z innymi obiektami w systemie,
            \item wykonywać pewne czynności na rzecz innych obiektów bez ujawniania, w jaki sposób zaimplementowano
            dane cechy.
        \end{itemize}
        \item \textbf{Enkapsulacja}
        \begin{itemize}
            \item ukrywanie szczegółów implementacji,
            \item obiekt nie może zmieniać stanu wewnętrznego innych obiektów w nieoczekiwany sposób,
            \item tylko wewnętrzne metody obiektu są uprawnione do zmiany jego stanu,
            \item każdy typ obiektu dostarcza innym obiektom swój "interfejs", który określa dopuszczalne metody współpracy.
        \end{itemize}
        \item \textbf{Polimorfizm}
        \begin{itemize}
            \item wykazywanie różnych form działania podczas wywoływania metody w zależności od typu obiektu,
            \item referencje i kolekcje obiektów mogą dotyczyć obiektów różnego typu, a wywołanie metody dla
            referencji spowoduje zachowanie odpowiednie dla pełnego typu obiektu wywoływanego.
        \end{itemize}
        \item \textbf{Dziedziczenie}
        \begin{itemize}
            \item porządkuje i wspomaga polimorfizm i enkapsulację,
            \item umożliwia definiowanie i tworzenie specjalizowanych obiektów,
            \item dla obiektów specjalizowanych nie trzeba redefiniować całej funkcjonalności, lecz tylko tę,
            której nie mają obiekty ogólniejsze.
        \end{itemize}
    \end{itemize}

    \subsubsection{GRASP}
    General Responsibility Assignment Software Patterns - zakres odpowiedzialności.
    \begin{itemize}
        \item \textbf{Creator} - określa kiedy podany obiekt powinien tworzyć inny obiekt, tzn. B powinien tworzyć A, jeśli:
        \begin{itemize}
            \item B agreguje A,
            \item B operuje na danych obiektu A,
            \item B używa bezpośrednio A,
            \item B dostarcza informacji niezbędnej do utworzenia A
        \end{itemize}
        \item \textbf{Information Expert} - określenie danych niezbędnych do wypełnienia nowej odpowiedzialności. Programista powinien delegować ją do obiektów, które
        zawierają najwięcej informacji pozwalających ją zrealizować.
        \item \textbf{Controller} - jego zadaniem jest: odbieranie informacji od UI, wykonywanie operacji oraz zwracanie ich wyników do UI.
        Programista deleguje zadania z UI do kontrolera, a kontroler w głąb systemu.
        \item \textbf{Low Coupling} - jak największa niezależność klas.
        \item \textbf{High Cohesion} - obiekt powinien skupiać się na jednej odpowiedzialności, która powinna być jasna i nie rozmyta.
        \item \textbf{Polymorphism}
        \item \textbf{Pure Fabrication} - powstawania w systemie obiektów, które nie reprezentują
        żadnego obiektu dziedziny, a kondensują funkcje udostępniane na rzecz innych obiektów.
        \item \textbf{Indirection} - aby zapewnić low coupling często zachodzi potrzeba
        dodania mediatora w komunikacji między biektami. Jego zadaniem jest jedynie wymiana informacji
        między obiektami. Taki obiekt deleguje zadania z jednego obiektu na rzecz drugiego. Projektowanie
        systemu z użyciem mediatora wpływa na poprawę hermetyzacji elementów systemu.
        Model MVC jest dobrym tego przykładem astosowania tej zasady. Kontroler jest mediatorem, co izoluje
        interfejs użytkownika od modelu.
        \item \textbf{Protected variations} - zasada mówiąca o zakresie modyfikacji w systemie
        wymaganym przez określoną zmianę. W systemie powinno się identyfikować punkty niestabilności i
        budować interfejsy wokół tych punktów. To ograniczy zakres zmian w przypadku, gdyby
        okazało się, że podany punkt niestabilności systemu wymaga zmian.
    \end{itemize}


    \subsubsection{Metazasady}
    \begin{itemize}
        \item \textbf{Don't repeat yourself - DRY}\\
        Jedno miejsce w systemie, na pojedynczą informację, co ułatwia późniejsze zmiany.
        Inna nazwa to \textbf{Single Source Of Truth} (SSOT), każda informacja w systemie powinna być przechowywana
        dokładnie raz, bo ułatwia to jej modyfikację.
        \item \textbf{Keep it simple, stupid - KISS}\\
        W projektowaniu interfejsów powyższą zasadę można nazwać \textbf{zasadą najmniejszego zaskoczenia}, czyli
        fragment kodu powinien robić dokładnie to co ma robić. Czasem trzeba wybrać, czy dany fragment kodu
        napisać z wykorzystaniem wzorca projektowego czy prostej konstrukcji.
    \end{itemize}


\end{document}
